import random

from collections import deque, namedtuple
from operator import eq

class Puzzle(namedtuple("PuzzleFields", ["board", "width", "zero_at"])):
    """
    A class representing an '8-puzzle'.
    - 'board' should be a square list of lists with integer entries 0...widthÂ²-1
       e.g. [[1,2,3],[4,0,6],[7,5,8]]
    """
    __slots__ = ()

    def __new__(cls, board, width, zero_at=None):
        if zero_at is None:
            zero_at = board.index(0)

        return super().__new__(cls, board, width, zero_at)

    def solved(self):
        """
        The puzzle is solved if the flattened board's numbers are in
        increasing order from left to right and the '0' tile is in the
        last position on the board
        """
        # 0 is on board, so must be in last place
        return all(map(eq, self.board, range(1, self.width**2)))

    def actions(self):
        """
        Return a list of 'move', 'action' pairs. 'move' can be called
        to return a new puzzle that results in sliding the '0' tile in
        the direction of 'action'.
        """
        at = self.zero_at

        if at >= self.width:
            yield self._move(at - self.width)

        if at + self.width < len(self.board):
            yield self._move(at + self.width)

        if at % self.width:
            yield self._move(at - 1)

        if (at + 1) % self.width:
            yield self._move(at + 1)

    def shuffle(self):
        """
        Return a new puzzle that has been shuffled with 1000 random moves
        """
        puzzle = self
        for _ in range(1000):
            puzzle = random.choice(list(puzzle.actions()))
        return puzzle

    def _move(self, to):
        """
        Return a new puzzle where 'zero_at' and 'to' tiles have been swapped.
        NOTE: all moves should be 'actions' that have been executed
        """
        a, b = min(self.zero_at, to), max(self.zero_at, to)

        board = list(self.board)
        board[a], board[b] = board[b], board[a]

        return Puzzle(tuple(board), self.width, to)

    def pprint(self):
        for i in range(0, len(self.board), self.width):
            print(self.board[i:i+self.width])

class Node(namedtuple("NodeFields", ["puzzle", "parent"])):
    """
    A class representing an Solver node
    - 'puzzle' is a Puzzle instance
    - 'parent' is the preceding node generated by the solver, if any
    - 'action' is the action taken to produce puzzle, if any
    """
    __slots__ = ()

    def __new__(cls, puzzle, parent=None):
        return super().__new__(cls, puzzle, parent)

    @property
    def action(self):
        if self.parent is None:
            return None

        diff_to_action = {
            +self.puzzle.width: 'D',
            -self.puzzle.width: 'U',
            +1: 'R',
            -1: 'L',
        }

        return diff_to_action[self.puzzle.zero_at - self.parent.puzzle.zero_at]


def path(node):
    """
    Reconstruct a path from to the root 'parent'
    """
    seen = []
    while node is not None:
        seen.append(node)
        node = node.parent
    return reversed(seen)


def solve(start):
    """
    Perform breadth first search and return a path
    to the solution, if it exists (otherwise None).
    """
    queue = deque([Node(start)])
    seen  = {start}

    if start.solved():
        return path(Node(start, None))

    while queue:
        node = queue.pop()

        for move in node.puzzle.actions():
            if move.board not in seen:
                if move.solved():
                    return path(Node(move, node))

                queue.appendleft(Node(move, node))
                seen.add(move.board)
                """
    stack = Stack()
    stack.push([Node(start)])
    seen = {start}
    if start.solved():
        return path(Node(start, None))
    while not stack.isEmpty():
        node = stack.top()
        stack.pop()
        for move in node.puzzle.actions():
            if move.board not in seen:
                if move.solved():
                    return path(Node(move, node))

                stack.push(Node(move, node))
                seen.add(move.board) 
                """
def main():
    board = 1, 6, 2, 0, 7, 3, 8, 4, 5

    puzzle = Puzzle(board, 3)
    #puzzle = puzzle.shuffle()
    p = solve(puzzle)
    if p is None:
        print("No solutions")
    for node in p:
        print(node.action)
        node.puzzle.pprint()
        print()


if __name__ == "__main__":
    main()
